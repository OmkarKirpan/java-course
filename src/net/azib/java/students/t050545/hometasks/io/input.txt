   Интернет-Университет Информационных Технологий 
   http://www.INTUIT.ru 


		Базы данных: модели, разработка, реализация



3. Лекция: Теоретико-графовые модели данных: версия для печати и PDA 
Лекция посвящена первым теоретико-графовым моделям, использовавшимся в ранних системах управления БД 




Как уже упоминалось ранее, эти модели отражают совокупность объектов реального мира в виде графа взаимосвязанных информационных объектов. В зависимости от типа графа выделяют иерархическую или сетевую модели. Исторически эти модели появились раньше, и в настоящий момент они используются реже, чем более современная реляционная модель данных. Однако до сих пор существуют системы, работающие на основе этих моделей, а одна из концепций развития объектно-ориентированных баз данных предполагает объединение принципов сетевой модели с концепцией реляционной.
Иерархическая модель данных

Иерархическая модель данных является наиболее простой среди всех даталогических моделей. Исторически она появилась первой среди всех даталогических моделей: именно эту модель поддерживает первая из зарегистрированных промышленных СУБД IMS фирмы IBM.

Появление иерархической модели связано с тем, что в реальном мире очень многие связи соответствуют иерархии, когда один объект выступает как родительский, а с ним может быть связано множество подчиненных объектов. Иерархия проста и естественна в отображении взаимосвязи между классами объектов.

Основными информационными единицами в иерархической модели являются: база данных (БД), сегмент и поле. Поле данных определяется как минимальная, неделимая единица данных, доступная пользователю с помощью СУБД. Например, если в задачах требуется печатать в документах адрес клиента, но не требуется дополнительного анализа полного адреса, то есть города, улицы, дома, квартиры, то мы можем принять весь адрес за элемент данных, и он будет храниться полностью, а пользователь сможет получить его только как полную строку символов из БД. Если же в наших задачах существует анализ частей, составляющих адрес, например города, где расположен клиент, то нам необходимо выделить город как отдельный элемент данных, только в этом случае пользователь может получить

к нему доступ и выполнить, например, запрос на поиск всех клиентов, которые проживают в конкретном городе, например в Париже. Однако если пользователю понадобится и полный адрес клиента, то остальную информацию по адресу также необходимо хранить в отдельном поле, которое может быть названо, например, Сокращенный адрес. В этом случае для каждого клиента в БД хранится как Город, так и Сокращенный адрес.

Сегмент в терминологии Американской Ассоциации по базам данных DBTG (Data Base Task Group) называется записью, при этом в рамках иерархической модели определяются два понятия: тип сегмента или тип записи и экземпляр сегмента или экземпляр записи.

Тип сегмента — это поименованная совокупность типов элементов данных, в него входящих. Экземпляр сегмента образуется из конкретных значений полей или элементов данных, в него входящих. Каждый тип сегмента в рамках иерархической модели образует некоторый набор однородных записей. Для возможности различия отдельных записей в данном наборе каждый тип сегмента должен иметь ключ или набор ключевых атрибутов (полей, элементов данных). Ключом называется набор элементов данных, однозначно идентифицирующих экземпляр сегмента. Например, рассматривая тип сегмента, описывающий сотрудника организации, мы должны выделить те характеристики сотрудника, которые могут его однозначно идентифицировать в рамках БД предприятия. Если предположить, что на предприятии могут работать однофамильцы, то, вероятно, наиболее надежным будет идентифицировать сотрудника по его табельному номеру. Однако если мы будем строить БД, содержащую описание множества граждан, например нашей страны, то, скорее всего, нам придется в качестве ключа выбрать совокупность полей, отражающих его паспортные данные.

В иерархической модели сегменты объединяются в ориентированный древовидный граф. При этом полагают, что направленные ребра графа отражают иерархические связи между сегментами: каждому экземпляру сегмента, стоящему выше по иерархии и соединенному с данным типом сегмента, соответствует несколько (множество) экземпляров данного (подчиненного) типа сегмента. Тип сегмента, находящийся на более высоком уровне иерархии, называется логически исходным по отношению к типам сегментов, соединенным с данным направленными иерархическими ребрами, которые в свою очередь называются логически подчиненными по отношению к этому типу сегмента. Иногда исходные сегменты называют сегментами-предками, а подчиненные сегменты называют сегментами-потомками.



Рис. 3.1.  Пример иерархических связей между сегментами


На концептуальном уровне определяется понятие схемы БД в терминологии иерархической модели.

Схема иерархической БД представляет собой совокупность отдельных деревьев, каждое дерево в рамках модели называется физической базой данных. Каждая физическая БД удовлетворяет следующим иерархическим ограничениям:
в каждой физической БД существует один корневой сегмент, то есть сегмент, у которого нет логически исходного (родительского) типа сегмента; 
каждый логически исходный сегмент может быть связан с произвольным числом логически подчиненных сегментов; 
каждый логически подчиненный сегмент может быть связан только с одним логически исходным (родительским ) сегментом. 

Очень важно понимать различие между сегментом и типом сегмента — оно такое же, как между типом переменной и самой переменной: сегмент является экземпляром типа сегмента. Например, у нас может быть тип сегмента Группа (Номер, Староста) и сегменты этого типа, такие как (4305, Петров Ф. И.) или (383, Кустова Т. С).

Между экземплярами сегментов также существуют иерархические связи. Рассмотрим, например, иерархический граф, представленный на рис. 3.2.



Рис. 3.2.  Пример структуры иерархического дерева

Каждый тип сегмента может иметь множество соответствующих ему экземпляров. Между экземплярами сегментов также существуют иерархические связи.

На рис. 3.3 представлены 2 экземпляра иерархического дерева соответствующей структуры.



Рис. 3.3.  Пример двух экземпляров данного дерева


Экземпляры-потомки одного типа, связанные с одним экземпляром сегмента-предка, называют "близнецами". Так, для нашего примера экземпляры b1, b2 и b3 являются "близнецами", но экземпляр b4 подчинен другому экземпляру родительского сегмента, и он не является "близнецом" по отношению к экземплярам b1, b2 и b3. Набор всех экземпляров сегментов, подчиненных одному экземпляру корневого сегмента, называется физической записью. Количество экземпляров-потомков может быть разным для разных экземпляров родительских сегментов, поэтому в общем случае физические записи имеют разную длину. Так, используя принцип линейной записи иерархических графов, пример на рис. 3.3 можно представить в виде двух записей:
а1 b1 b2 b3 c1 d1 d2 e1 	a2 b4 b5 c2 d3 d4 e2 e3 e4 
Запись 1 	Запись 2 


Как видно из нашего примера, физические записи в иерархической модели различаются по длине и структуре.
Язык описания данных иерархической модели

В рамках иерархической модели выделяют языковые средства описания данных (DDL, Data Definition Language) и средства манипулирования данными (DML, Data Manipulation Language).

Каждая физическая база описывается набором операторов, определяющих как ее логическую структуру, так и структуру хранения БД. Описание начинается с о-ператора DBD (Data Base Definition):
DBD Name = < имя БД>, ACCESS = < способ доступа>

Способ доступа определяет способ организации взаимосвязи физических записей. Определено 5 способов доступа: HSAM — hierarchical sequential access method (иерархически последовательный метод), HISAM — hierarchical index sequential access method (иерархически индексно-последовательный метод), HDAM — hierarchical direct access method (иерархически прямой метод), HIDAM — hierarchical index direct access method (иерархически индексно-прямой метод), INDEX — индексный метод.

Далее идет описание наборов данных, предназначенных для хранения БД:
DATA SET DD1 = < имя оператора, определяющего хранимый набор данных>, 
DEVICE =< устройство хранения БД>, 
[OVFLW = < имя области переполнения>]

Так как физические записи имеют разную длину, то при модификации данных запись может увеличиться и превысит исходную длину записи до модификации. В этом случае при определенных методах хранения может понадобиться дополнительное пространство хранения, где и будут размещены дополнительные данные. Это пространство и называется областью переполнения.

После описания всей физической БД идет описание типов сегментов, ее составляющих, в соответствии с иерархией. Описание сегментов всегда начинается с описания корневого сегмента. Общая схема описания типа сегмента такова:
SEGM NAME = < имя сегмента>, 
  BYTES =< размер в байтах>,
  FREQ = <средняя частота реализаций сегмента под одним исходным> 
  PARENT = <имя родительского сегмента>

Параметр FREQ определяет среднее количество экземпляров данного сегмента, связанных с одним экземпляром родительского сегмента. Для корневого сегмента это число возможных экземпляров корневого сегмента.

Для корневого сегмента параметр PARENT равен 0 (нулю).

Далее для каждого сегмента дается описание полей:
FIELD NAME = {(<имя поля> [, SEQ],{U | M}) | <имя поля> },
   START = < номер байта, с которого начинается значения поля >, 
   BYTES = <размер поля в байтах>, 
   TYPE = {X | P | C}

Признак SEQ — задается для ключевого поля, если экземпляры данного сегмента физически упорядочены в соответствии со значениями данного поля.

Параметр U задается, если значения ключевого поля уникальны для всех экземпляров данного сегмента, M — в противном случае. Если поле является ключевым, то его описание задается в круглых скобках, в противном случае имя поля задается без скобок. Параметр TYPE определяет тип данных. Для ранних иерархических моделей были определены только три типа данных: X — шестнадцатеричный, P —упакованный десятичный, C — символьный.

Заканчивается описание схемы вызовом процедуры генерации:
DBDGEN — указывает на конец последовательности управляющих операторов описания БД; 
FINISH — устанавливает ненулевой код завершения при обнаружении ошибки; 
END — конец. 

В системе может быть несколько физических БД (ФБД), но каждая из них описывается отдельно своим DBD и ей присваивается уникальное имя. Каждая ФБД содержит только один корневой сегмент. Совокупность ФБД образует концептуальную модель данных.

Внешние модели

При работе с иерархической моделью каждая программа, пользователь или приложение определяет свою внешнюю модель. Внешняя модель представляет собой совокупность поддеревьев для физических баз данных, с которыми работает данный пользователь. Каждый подграф внешней модели в обязательном порядке должен содержать корневой тип сегмента соответствующей физической базы данных концептуальной модели.

Представление внешней модели называется логической базой данных и определяется совокупностью блоков связи данного приложения с физическими БД, входящими в концептуальную схему БД. Блок связи — PCB, program communication bloc — описывает связь с одной физической БД по следующим правилам:
DBD NAME = < имя логической БД (подсхемы)> , 
ACCESS = LOGICAL
DATA SET = LOGICAL.
SEGM NAME = <имя сегмента в подсхеме>, 
PARENT =<имя родительского сегмента в подсхеме>, 
SOURSE =(Имя соответствующего сегмента ФБД, имя ФБД)
...
DBDGEN
FINISH
END

Совокупность блоков PCB образует полное внешнее представление данного приложения, называемое "блоком спецификации программ" (PSB, program specification block).

Рассмотрим пример иерархической БД.

Наша организация занимается производством и продажей компьютеров, в рамках производства мы комплектуем компьютеры из готовых деталей по индивидуальным заказам. У нас существует несколько базовых моделей, которые мы продаем без предварительных заказов по наличию на складе. В организации существуют несколько филиалов (рис. 3.4) и несколько складов, на которых хранятся комплектующие. Нам необходимо вести учет продаваемой продукции.



Рис. 3.4.  Физическая БД "Филиалы"

Какие задачи нам надо решать в ходе разработки приложения?
При приеме заказа мы должны выяснить, какую модель заказывает заказчик: типичную или индивидуальную комплектацию. 
Если заказывается типичная модель, то выясняется, какая модель и есть ли она в наличии, если модель есть, то надо уменьшить количество компьютеров данной модели в данном филиале на покупаемое количество. На этом будем считать заказ выполненным, однако при оформлении заказа может потребоваться задание полной спецификации покупаемого изделия. 
Если заказывается индивидуальная модель, то требуется описать весь состав новой модели. 

Для того чтобы можно было бы принимать заказы на индивидуальные модели, нам понадобится информация о наличии конкретных деталей на складе, в этом случае нам необходимо второе дерево — Склады (см. рис. 3.5).



Рис. 3.5.  Физическая модель "Склады"

Язык манипулирования данными в иерархических базах данных

Для доступа к базе данных у пользователя должна быть сформирована специальная среда окружения, поддерживающая в явном виде имеющиеся навигационные операции. Для этого в ней должны храниться:
шаблоны всех записей логических баз данных, доступных пользователю; 
указатели на текущий экземпляр сегмента данного типа — для всех типов сегментов. 

Язык манипулирования данными в иерархической модели поддерживает в явном виде навигационные операции. Эти операции связаны с перемещением указателя, который определяет текущий экземпляр конкретного сегмента.

Все операторы в языке манипулирования данными можно разделить на 3 группы. Первую группу составляют операторы поиска данных.
Операторы поиска данных

Синтаксис:
GET UNIQUE <имя сегмента> WHERE <список поиска>;

список поиска состоит из последовательности условий вида:

<имя сегмента>.<имя поля>ОС <constant или имя другого поля данного сегмента или имя переменной>;

ОС — операция сравнения;

условия могут быть соединены логическими операциями И и ИЛИ {& , }.

Назначение:

Получить единственное значение.

Пример:

Найти типовую модель стоимостью не более $600, которая существует не менее чем в 10 экземплярах.

GET UNIQUE ТИПОВЫЕ МОДЕЛИ WHERE Типовые модели.Стоимость <= $600 AND Типовые модели.Количество на складе >= 10

Данная команда всегда ищет с начала БД и останавливается, найдя первый экземпляр сегмента, удовлетворяющий условиям поиска.

Синтаксис:
GET NEXT <имя сегмента> WHERE <список аргументов поиска> 

Назначение: 

Получить следующий экземпляр сегмента для тех же условий.

Пример:

Напечатать полный список заказов стоимостью не менее $500.
GET UNIQUE ИНДИВИДУАЛЬНЫЕ МОДЕЛИ 
WHERE Индивидуальные модели.Стоимость >= $500 
WHILE NOT FAIL (пока не конец поиска) DO
   PRINT № заказа, Стоимость, Количество
   GET NEXT ИНДИВИДУАЛЬНЫЕ МОДЕЛИ 
END

Синтаксис:
GET NEXT <имя сегмента> WITHIN PARENT [ where <дополн.условия>]

Назначение:

Получить следующий для того же исходного.

Пример:

Получить перечень винчестеров, имеющихся на складе номер 1, в количестве не менее 10 с объемом 10 Гбайт.
GET UNIQUE СКЛАД WHERE Склад.Номер = 1
GET NEXT ИЗДЕЛИЕ WITHIN PARENT 
   WHERE Изделие.Наименование = "Винчестер"
GET NEXT ХАРАКТЕРИСТИКИ WITHIN PARENT
   WHERE ХАРАКТЕРИСТИКИ.Параметр = 10 AND
   ХАРАКТЕРИСТИКИ.Единицы Измерения = Гб AND
   ХАРАКТЕРИСТИКИ.Величина > 10
While Not Fail (пока поиск не завершен) DO
   Get Next Within Parent
end
Операторы поиска данных с возможностью модификации
Найти и удержать единственный экземпляр сегмента. Эта операция подобна первой операции поиска GET UNIQUE, единственным отличием этой операции является то, что после выполнения этой операции над найденным экземпляром сегмента допустимы операции модификации (изменения) данных. 

Синтаксис:
GET HOLD UNIQUE <имя сегмента> 
WHERE <список поиска>
Найти и удержать следующий с теми же условиями поиска. Аналогично операции 4 эта операция дублирует вторую операции поиска GET NEXT с возможностью выполнения последующей модификации данных. 

Синтаксис:
GET HOLD NEXT [WHERE дополнительные условия>]
Получить и удержать следующий для того же родителя. Эта операция является аналогом операции поиска 3, но разрешает выполнение операций модификации данных после себя. 

Синтаксис:
GET HOLD NEXT WITHIN PARENT [ where <дополн.условия>]
Операторы модификации данных
Удалить 

Это первая из трех операций модификации.

Синтаксис:
DELETE

Эта команда не имеет параметров. Почему? Потому что операции модификации действуют на экземпляр сегмента, найденный командами поиска с удержанием. А он всегда единственный текущий найденный и удерживаемый для модификации экземпляр конкретного сегмента. Поэтому при выполнении команды удаления будет удален именно этот экземпляр сегмента.
Обновить 

Синтаксис:
UPDATE

Как же происходит обновление, если мы и в этой команде не задаем никаких параметров. СУБД берет данные из рабочей области пользователя, где в шаблонах записей соответствующих внутренних переменных находятся значения полей каждого сегмента внешней модели, с которой работает данный пользователь. Именно этими значениями и обновляется текущий экземпляр сегмента. Значит, перед тем как выполнить операции модификации UPDATE, необходимо присвоить соответствующим переменным новые значения.

Ввести новый экземпляр сегмента.
INSERT <имя сегмента>

Эта команда позволяет ввести новый экземпляр сегмента, имя которого определено в параметре команды. Если мы вводим данные в сегмент, который является подчиненным некоторому родительскому экземпляру сегмента, то он будет внесен в БД и физически подключен к тому экземпляру родительского сегмента, который в данный момент является текущим.

Как видим, набор операций поиска и манипулирования данными в иерархической БД невелик, но он вполне достаточен для получения доступа к любому экземпляру любого сегмента БД. Однако следует отметить, что способ доступа, который применяется в данной модели, связан с последовательным перемещением от одного экземпляра сегмента к другому. Такой способ напоминает движение летательного аппарата или корабля по заданным координатам и называется навигационным.
Сетевая модель данных

Стандарт сетевой модели впервые был определен в 1975 году организацией CODASYL (Conference of Data System Languages), которая определила базовые понятия модели и формальный язык описания.

Базовыми объектами модели являются:
элемент данных; 
агрегат данных; 
запись; 
набор данных. 

Элемент данных — то же, что и в иерархической модели, то есть минимальная информационная единица, доступная пользователю с использованием СУБД.

Агрегат данных соответствует следующему уровню обобщения в модели. В модели определены агрегаты двух типов: агрегат типа вектор и агрегат типа повторяющаяся группа.

Агрегат данных имеет имя, и в системе допустимо обращение к агрегату по имени. Агрегат типа вектор соответствует линейному набору элементов данных. Например, агрегат Адрес может быть представлен следующим образом:
Адрес 
Город 	Улица 	дом 	квартира 


Агрегат типа повторяющаяся группа соответствует совокупности векторов данных. Например, агрегат Зарплата соответствует типу повторяющаяся группа с числом повторений 12.
Зарплата 
Месяц 	Сумма 
.	.


Записью называется совокупность агрегатов или элементов данных, моделирующая некоторый класс объектов реального мира. Понятие записи соответствует понятию "сегмент" в иерархической модели. Для записи, так же как и для сегмента, вводятся понятия типа записи и экземпляра записи.

Следующим базовым понятием в сетевой модели является понятие "Набор". Набором называется двухуровневый граф, связывающий отношением "один-ко-многим" два типа записи.




Набор фактически отражает иерархическую связь между двумя типами записей. Родительский тип записи в данном наборе называется владельцем набора, а дочерний тип записи — членом того же набора.

Для любых двух типов записей может быть задано любое количество наборов, которые их связывают. Фактически наличие подобных возможностей позволяет промоделировать отношение "многие-ко-многим" между двумя объектами реального мира, что выгодно отличает сетевую модель от иерархической. В рамках набора возможен последовательный просмотр экземпляров членов набора, связанных с одним экземпляром владельца набора.

Между двумя типами записей может быть определено любое количество наборов: например, можно построить два взаимосвязанных набора. Существенным ограничением набора является то, что один и тот же тип записи не может быть одновременно владельцем и членом набора.

В качестве примера рассмотрим таблицу, на основе которой организуем два набора и определим связь между ними:
Преподаватель 	Группа 	День недели 	№ пары 	Аудитория 	Дисциплина 
Иванов 	4306 	Понедельник 	1 	22-13 	КИД 
Иванов 	4307 	Понедельник 	2 	22-13 	КИД 
Карпова 	4307 	Вторник 	2 	22-14 	БЗ и ЭС 
Карпова 	4309 	Вторник 	4 	22-14 	БЗ и ЭС 
Карпова 	4305 	Вторник 	1 	22-14 	БД 
Смирнов 	4306 	Вторник 	3 	23-07 	ГВП 
Смирнов 	4309 	Вторник 	4 	23-07 	ГВП 






Экземпляров набора Ведет занятия будет 3 (по числу преподавателей), экземпляров набора Занимается у будет 4 (по числу групп). На рис. 3.6 представлены взаимосвязи экземпляров данных наборов.



Рис. 3.6.  Пример взаимосвязи экземпляров двух наборов

Среди всех наборов выделяют специальный тип набора, называемый "Сингулярным набором", владельцем которого формально определена вся система. Сингулярный набор изображается в виде входящей стрелки, которая имеет собственно имя набора и имя члена набора, но у которой не определен тип записи "Владелец набора". Например, сингулярный набор М.





Сингулярные наборы позволяют обеспечить доступ к экземплярам отдельных типов данных, поэтому если в задаче алгоритм обработки информации предполагает обеспечение произвольного доступа к некоторому типу записи, то для поддержки этой возможности необходимо ввести соответствующий сингулярный набор.

В общем случае сетевая база данных представляет совокупность взаимосвязанных наборов, которые образуют на концептуальном уровне некоторый граф.
Язык описания данных в сетевой модели

Язык описания данных в сетевой модели имеет несколько разделов:
описание базы данных — области размещения; 
описания записей — элементов и агрегатов (каждого в отдельности); 
описания наборов (каждого в отдельности). 
SCHEMA IS <Имя БД>.
AREA NAME IS <Имя физической области>.
RECORD NAME IS <Имя записи (уникальное)>

Для каждой записи определяется способ размещения экземпляров записи данного типа:
LOCATION MODE IS {DIRECT (напрямую) |
   CALC <Имя программы> USING <[Список пер.>] 
   DUPLICATE ARE [NOT] ALLOWED
      VIA <Имя набора> SET (рядом с записями владельца)
      SYSTEM (решать будет система)}

Каждый тип записи должен быть приписан к некоторой физической области размещения:
WITHIN <Имя области размещения> AREA

После описания записи в целом идет описание внутренней структуры:
<Имя уровня> <Имя данного> <Шаблон> <Тип>

Номер уровня определяет уровень вложенности при описании элементов и агрегатов данных. Первый уровень — сама запись. Поэтому элементы или агрегаты данных имеют уровень начиная со второго. Если данное соответствует агрегату, то любая его составляющая добавляет один уровень вложенности.

Если агрегат является вектором, то он описывается как
<Номер уровня> <Имя агрегата>.<Номер уровня> 
<Имя 1-й сост.>

а если — повторяющейся группой, то следующим образом: 
<Номер уровня> <Имя агрегата>.OCCURS <N> TIMES

где N — среднее количество элементов в группе.

Описание набора и порядка включения членов в него выглядит следующим образом:
SET NAME IS <Имя набора>;
OWNER IS (<Имя владельца> | SYSTEM).

Далее указывается порядок включения новых экземпляров члена данного набора в экземпляр набора:
ORDER PERMANENT INSERTION IS {SORTED | NEXT | PREV | LAST | FIRST}

После этого описывается член набора с указанием способа включения и способа исключения экземпляра — члена набора из экземпляра набора.
MEMBER IS <Имя члена набора> 
   {AUTOMATIC | MANUAL} {MANDATORY | OPTIONAL} 
KEY IS (ACCENDING | DESCENDING) <Имя элемента данных>

При автоматическом включении каждый новый экземпляр члена набора автоматически попадает в текущий экземпляр набора в соответствии с заданным ранее порядком включения. При ручном способе экземпляр члена набора сначала попадает в БД, а только потом командой CONNECT может быть включен в конкретный экземпляр набора.

Если задан способ исключения MANDATORY, то экземпляр записи, исключаемый из набора, автоматически исключается и из базы данных. Иначе просто разрываются связи.

Внешняя модель при сетевой организации данных поддерживается путем описания части общего связного графа.
Язык манипулирования данными в сетевой модели

Все операции манипулирования данными в сетевой модели делятся на навигационные операции и операции модификации.

Навигационные операции осуществляют перемещение по БД путем прохождения по связям, которые поддерживаются в схеме БД. В этом случае результатом является новый единичный объект, который получает статус текущего объекта.

Операции модификации осуществляют как добавление новых экземпляров отдельных типов записей, так и экземпляров новых наборов, удаление экземпляров записей и наборов, модификацию отдельных составляющих внутри конкретных экземпляров записей. Средства модификации данных сведены в табл. 3.1:
Таблица 3.1. Операторы манипулирования данными в сетевой моделиОперация 	Назначение 
READY 	Обеспечение доступа данного процесса или пользователя к БД (сходна по смыслу с операцией открытия файла) 
FINISH 	Окончание работы с БД 
FIND 	Группа операций, устанавливающих указатель найденного объекта на текущий объект 
GET 	Передача найденного объекта в рабочую область. Допустима только после FIND 
STORE 	Помещение в БД записи, сформированной в рабочей области 
CONNECT 	Включение текущей записи в текущий экземпляр набора 
DISCONNECT 	Исключение текущей записи из текущего экземпляра набора 
MODIFY 	Обновление текущей записи данными из рабочей области пользователя 
ERASE 	Удаление экземпляра текущей записи 


В рабочей области пользователя хранятся шаблоны записей, программные переменные и три типа указателей текущего состояния:
текущая запись процесса (код или ключ последней записи, с которой работала данная программа); 
текущая запись типа записи (для каждого типа записи ключ последней записи, с которой работала программа); 
текущая запись типа набор (для каждого набора с владельцем T1 и членом T2 указывается, T1 или T2 были последней обрабатываемой записью). 

На рис. 3.7 представлена концептуальная модель торгово-посреднической организации.



Рис. 3.7.  Схема БД "Торговая фирма"

При необходимости возможно описание элементов данных, которые не принадлежат непосредственно данной записи, но при ее обработке часто используются. Для этого используется тип VIRTUAL с обязательным указанием источника данного элемента данных.
RECORD Цены
02 Цена TYPE REAL
02 Товар VIRTUAL
SOURCE IS Товары.НаименованиеТовара
OF OWNER OF Товар-Цены SET

Наиболее интересна операция поиска (FIND), так как именно она отражает суть навигационных методов, применяемых в сетевой модели. Всего существует семь типов операций поиска:
По ключу (запись должна быть описана через CALC USING ...): 
FIND <Имя записи> 
RECORD BY CALC KEY <Имя параметра>
Последовательный просмотр записей данного типа: 
FIND DUPLICATE <Имя записи> 
RECORD BY CALC KEY
Найти владельца текущего экземпляра набора: 
FIND OWNER OF CURRENT <Имя набора> SET
Последовательный просмотр записей—членов текущего экземпляра набора: 
FIND (FIRST | NEXT) <Имя записи> 
RECORD IN CURRENT <Имя набора> 
SET
Просмотр записей—членов экземпляра набора, специфицированных рядом полей: 
FIND [DUPLICATE] <Имя записи> 
RECORD IN CURRENT <Имя набора> 
SET USING <Список полей>
Сделать текущей записью процесса текущий экземпляр набора: 
FIND CURRENT OF <Имя набора> SET
Установить текущую запись процесса: 
FIND CURRENT OF <Имя записи> RECORD

Например, алгоритм и программа печати заказов, сделанных Петровым, будут выглядеть так:





	

© INTUIT.ru, 2003-2009. Все права защищены.